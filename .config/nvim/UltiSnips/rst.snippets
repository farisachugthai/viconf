# rst.snippets
# ==============
# -*- coding: utf-8 -*-
# vim:set ft=markdown noet sts=4 sw=4 ts=4:

#######################################################################
#                    # Personal Snippets you wrote                    #
#######################################################################


snippet inlink "Create an internal link"
:ref:`${VISUAL:'link'}`
endsnippet

snippet table "table from sphinx cheatsheet"

==================   ============
Name                 Age
==================   ============
John D Hunter        40
Cast of Thousands    41
And Still More       42
==================   ============
endsnippet


snippet cb "Code Block. Must have 1 blank line surrounding!" b
.. code-block:: ${1:python}

	${2:${VISUAL:code}}

$0
endsnippet


# TODO:
# shit are the backticks gonna need to be escaped? remember to look for that
snippet code "Inline code" b
``${VISUAL:1}``
endsnippet


# There are a few different ways to do
###########
#  links  #
###########


snippet link "External URL. A space is required between the text and URL!" b
`Link text <https://github.com/>`
endsnippet


snippet link "Separated link and target." b

${1:optional text leading into} ${2:`a link`_}

.. _a link: https://somedomain.com

endsnippet



#### Probably all I'm gonna keep from UltiSnips


#http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions
#SPECIFIC_ADMONITIONS = ["attention", "caution", "danger",
#                        "error", "hint", "important", "note",
#                        "tip", "warning"]
##http://docutils.sourceforge.net/docs/ref/rst/directives.html
#DIRECTIVES = ['topic','sidebar','math','epigraph',
#              'parsed-literal','code','highlights',
#              'pull-quote','compound','container','table','csv-table',
#              'list-table','class','sectnum',
#              'role','default-role','unicode',
#              'raw']

#NONE_CONTENT_DIRECTIVES = ['rubric', 'contents', 'header',
#                          'footer', 'date', 'include', 'title']

#INCLUDABLE_DIRECTIVES = ['image', 'figure', 'include']



############
#  Sphinx  #
############

snippet sid "SideBar" b
.. sidebar:: ${1:SideBar Title}

	${2:${VISUAL:SideBar Content}}
endsnippet

##########
# Snipmate
##########


snippet para "Paragraph"
:${1:field name}: ${0:field body}
endsnippet

snippet * "Italics"
*${1:Emphasis}* ${0}
endsnippet

snippet ** "Bold"
**${1:Strong emphasis}** ${0}
endsnippet

snippet bold "bold" b
**${1:Strong emphasis}** ${0}
endsnippet


snippet url "External url"
\`${1:hyperlink-name}\`_
.. _\`$1\`: ${0:link-block}
endsnippet

snippet title= "Title underlined with ==='s" b
${1:Title}
=====${2:=}
${0}
endsnippet

snippet title- "Title underlined with ---'s" b
${1:Title}
-----${2:-}
${0}
endsnippet

# Directives
# ------------

snippet img: "image link directive"
	.. |${0:alias}| image:: ${1:img}
endsnippet

snippet fig:
	.. figure:: ${1:img}
		:alt: ${0:alter text}

		$2
endsnippet

snippet cont:
	.. contents::
		${0:content}
endsnippet

snippet code:
	.. code:: ${1:type}

		${0:write some code}
endsnippet

snippet tip:
	.. tip::
		${0:Tip for anyone having trouble.}
endsnippet

snippet note:
	.. note::
		${0:Take note of the fact that}
endsnippet

snippet war:
	.. warning::
		${0:Warning:}
endsnippet

snippet imp:
	.. important::
		${0:Important notice:}
endsnippet

snippet att:
	.. attention::
		${0:Attention!}
endsnippet

snippet dan:
	.. danger::
		${0:Danger:}
endsnippet

snippet err:
	.. error::
		${0:Error:}
endsnippet

snippet cau:
	.. caution::
		${0:Take precaution with:}
endsnippet

# Fixed whitespace with qq
# j<>j<<>>3j
# q
# 5@q




################################################################################
#                                # neosnippets                                 #
################################################################################



snippet quickstart "Shougos RST one snippet summary" b
===========================
${1:content_name}
===========================

.. contents:: ${1}

${2:title1}
====================================

${3:subtitle1}
-----------------------------------

${4:subtitle2}
-----------------------------------

${5:subtitle3}
-----------------------------------

${6:title2}
====================================

${7:subtitle1}
-----------------------------------

${8:subtitle2}
-----------------------------------

$0
endsnippet


snippet     toctree "directive_toctree" b
	.. toctree::
		:maxdepth: ${1:2}

		${2:#:FILES}
endsnippet




# While simpler and easier to read, these snipmate snippets are just undeniably
# inferior. As a result UltiSnips and snipmates have been added so we'll
# manually delete the duplicated ones.


# Having parsed through it tue whole file is trash
# Neosnippets didn't do a bad job though.
###########################################################################
#                              UltiSnips                                    #
###########################################################################

# so can i rewrite this whole thing using neovim?
# how do you import vim in the repl? are you allowed to do that?
global !p

import vim
from os import path as ospath
from string import Template
# I swear the snip option has a few of these ready to go
import re
from collections import Counter

from vimsnippets import complete

# `<http://docutils.sourceforge.net/docs/ref/rst/roles.html>`

TEXT_ROLES = ['emphasis','literal','code','math',
              'pep-reference','rfc-reference',
              'strong','subscript','superscript',
              'title-reference','raw']
TEXT_ROLES_REGEX = r'\.\.\srole::?\s(w+)'
# CJK chars
# http://stackoverflow.com/questions/2718196/find-all-chinese-text-in-a-string-using-python-and-regex
CJK_RE = re.compile(u'[⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〺〻㐀-䶵一-鿃豈-鶴侮-頻並-龎]', re.UNICODE)

#http://www.pygal.org/en/stable/documentation/types/index.html
CHART_TYPES = ["Line", "StackedLine", "HorizontalLine", "Bar", "StackedBar", "HorizontalBar", "Histogram", "XY", "DateLine", "TimeLine", "TimeDeltaLine", "DateTimeLine", "Pie", "Radar", "Box", "Dot", "Funnel", "Gauge", "SolidGauge", "Pyramid", "Treemap"]

def has_cjk(s):
    """Detect if s contains CJK characters."""
    return CJK_RE.search(s) is not None


def real_filename(filename):
    """peel extension name off if possible
    # i.e. "foo.bar.png will return "foo.bar"
    """
    return ospath.splitext(filename)[0]


def check_file_exist(rst_path, relative_path):
    """For RST file, it can just include files as relative path.

    :param rst_path: absolute path to rst file
    :param relative_path: path related to rst file
    :return: relative file's absolute path if file exist
    """
    abs_path = ospath.join(ospath.dirname(rst_path), relative_path)
    if ospath.isfile(abs_path):
        return abs_path


try:
    rst_char_len = vim.strwidth  # Requires Vim 7.3+
except AttributeError:
    from unicodedata import east_asian_width
    def rst_char_len(s):
        """Return the required over-/underline length for s."""
        result = 0
        for c in s:
            result += 2 if east_asian_width(c) in ('W', 'F') else 1
        return result


def make_items(times, leading='+'):
    """Make lines with leading char multiple times.

    :param: times, how many times you need
    :param: leading, leading character
    """
    times = int(times)
    if leading == 1:
        msg = ""
        for x in range(1, times+1):
            msg += "%s. Item\n" % x
        return msg
    else:
        return ("%s Item\n" % leading) * times


def look_up_directives(regex, fpath):
    """Find all directive args in given file
    :param: regex, the regex that needs to match
    :param: path, to path to rst file

    :return: list, empty list if nothing matches
    """
    try:
        with open(fpath) as source:
            match = re.findall(regex, source.read())
    except IOError:
        match = []
    return match


# so what the fuck? def doesn't take an arg, the docstring says path
# and its to determine embedded syntaxes in a file.
def get_popular_code_type():
    """Find most frequent filetype in the file

    :param path: file to detect

    :return: string, most popular code type in file
    """
    buf = "".join(vim.current.buffer)
    types = re.findall(r'[:|\.\.\s]code::?\s(\w+)', buf)
    try:
        popular_type = Counter(types).most_common()[0][0]
    except IndexError as e:
        # what the hell is this?!?
        # popular_type = "lua" # Don't break default
        # no i just want the exception
        print(e)
    return popular_type
endglobal

snippet part "Part" b
`!p snip.rv = rst_char_len(t[1])*'#'`
${1:${VISUAL:Part name}}
`!p snip.rv = rst_char_len(t[1])*'#'`
$0
endsnippet

snippet chap "Chapter" b
`!p snip.rv = rst_char_len(t[1])*'*'`
${1:${VISUAL:Chapter name}}
`!p snip.rv = rst_char_len(t[1])*'*'`
$0
endsnippet

snippet sec "Section" b
${1:${VISUAL:Section name}}
`!p snip.rv = rst_char_len(t[1])*'='`
$0
endsnippet

snippet ssec "Subsection" b
${1:${VISUAL:Subsection name}}
`!p snip.rv = rst_char_len(t[1])*'-'`
$0
endsnippet

snippet sssec "Subsubsection" b
${1:${VISUAL:Subsubsection name}}
`!p snip.rv = rst_char_len(t[1])*'^'`
$0
endsnippet

snippet para "Paragraph" b
${1:${VISUAL:Paragraph name}}
`!p snip.rv = rst_char_len(t[1])*'"'`
$0
endsnippet

# WHAT ARE THESE DOUBLE IF'S!
snippet em "Emphasize string" i
`!p
# dirty but works with CJK character detection
if has_cjk(vim.current.line):
    snip.rv ="\ "`*${1:${VISUAL:Em}}*`!p
if has_cjk(vim.current.line):
    snip.rv ="\ "
else:
    snip.rv = " "
`$0
endsnippet

# I'm about to take a weedwhacker to this file.
snippet st "Strong string" i
`!p
if has_cjk(vim.current.line):
    snip.rv ="\ "`**${1:${VISUAL:Strong}}**`!p
if has_cjk(vim.current.line):
    snip.rv ="\ "
else:
    snip.rv = " "
`$0
endsnippet

# usage: li 4<tab>
# which will extand into a unordered list contains 4 items
# NICE --------^
# wait who typed those notes. because that clearly indicates that you can use
# regexes as trigger words what the fuck
snippet "li(st)? (?P<num>\d+)" "List" br
$0
`!p
snip.rv = make_items(match.groupdict()['num'])
`
endsnippet

snippet "ol(st)? (?P<num>\d+)" "Order List" br
$0
`!p
# usage: ol 4<tab>
# which will extand into a ordered list contains 4 items
snip.rv = make_items(match.groupdict()['num'], 1)
`
endsnippet
###########################################################################
#                         More Specialized Stuff.                         #
###########################################################################

# match snippets :
# img, inc, fig
snippet id "Includable Directives" b
`!p
real_name=real_filename(ospath.basename(t[2]))
di=t[1][:2]

link=""
content=""

if di == 'im':
    link = "|{0}|".format(real_name)

if di == 'fi':
    content="""
    :alt: {0}

    {0}""".format(real_name)
`
..`!p snip.rv = " %s" % link if link else ""` $1`!p
snip.rv=complete(t[1], INCLUDABLE_DIRECTIVES)
`:: ${2:${VISUAL:file}}`!p
if content:
    snip.rv +="    "+content`
`!p
# Tip of whether file is exist in comment type
if not check_file_exist(path, t[2]):
    snip.rv='.. FILE {0} does not exist'.format(t[2])
else:
    snip.rv=""
`$0
endsnippet

snippet di "Directives" b
.. $1`!p snip.rv=complete(t[1], DIRECTIVES)`:: $2

	${3:${VISUAL:Content}}
$0
endsnippet

snippet nd "None Content Directives" b
.. $1`!p snip.rv=complete(t[1], NONE_CONTENT_DIRECTIVES)`:: $2
$0
endsnippet

snippet sa "Specific Admonitions" b
.. $1`!p snip.rv =complete(t[1], SPECIFIC_ADMONITIONS)`::

	${2:${VISUAL:Content}}

$0
endsnippet

#it will be trigger at start of line or after a word
snippet ro "Text Roles" w
\ :$1`!p snip.rv=complete(t[1],
                          TEXT_ROLES+look_up_directives(TEXT_ROLES_REGEX,
                                                        path))`:\`$2\`\
endsnippet

snippet eu "Embedded URI" i
`!p
if has_cjk(vim.current.line):
    snip.rv = "\ "`\`${1:${VISUAL:Text}} <${2:URI}>\`_`!p
if has_cjk(vim.current.line):
    snip.rv ="\ "
else:
    snip.rv = ""
`$0
endsnippet

snippet fnt "Footnote or Citation" i
[${1:Label}]_ $0

.. [$1] ${2:Reference}
endsnippet

# Only for Nikola — Static Site Generator
snippet chart "Pygal chart for Nikola" b
.. chart:: $1`!p snip.rv=complete(t[1], CHART_TYPES)`
	:title: '${2:Browser usage evolution (in %)}'
	:x_labels: [${3:"2002", "2003", "2004", "2005", "2006", "2007"}]

	'Firefox', [None, None, 0, 16.6, 25, 31]
	'Chrome',  [None, None, None, None, None, None]
	'IE',      [85.8, 84.6, 84.7, 74.5, 66, 58.6]
	'Others',  [14.2, 15.4, 15.3, 8.9, 9, 10.4]
$0
endsnippet

# vim:ft=snippets:
